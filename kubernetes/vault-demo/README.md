# Demo: Vault on Kubernetes

## Minikube

To enable Kubernetes CA in minikube installation, start it by running

    minikube start --extra-config=controller-manager.ClusterSigningCertFile="/var/lib/localkube/certs/ca.crt" --extra-config=controller-manager.ClusterSigningKeyFile="/var/lib/localkube/certs/ca.key"


## Preparations

Build containers by running following

    # run this if using minikube as target
    eval $(minikube docker-env)

    docker build -t demo-vault:0.9.0 docker/vault
    docker build -t demo-client:1.0.0 docker/client


Generate server certificate for Vault

    # compile cfssl tools to generate key and CSR
    # alternatively download pre-compiled binaries from https://pkg.cfssl.org/
    go get -v -u github.com/cloudflare/cfssl/cmd/...

    # generate private key and certificate signing request for Vault
    cfssl genkey configs/cfssl-vault-server-csr.json | cfssljson -bare vault

    # send CSR to kubernetes CA
    CSR=$(cat vault.csr | base64 | tr -d '\n') envsubst < manifests/vault-csr.yaml | kubectl create -f -

    # approve the request
    kubectl certificate approve vault

    # check that status changed to `Approved,Issued`.
    kubectl describe csr vault

    # fetch the certificate
    kubectl get csr vault -o jsonpath='{.status.certificate}' | base64 -d > vault.pem

    # remove the CSR
    kubectl delete csr vault

    # check that the certificate looks ok
    cfssl certinfo -cert vault.pem


## Deploy Vault

Create configmap for `vault.hcl` configuration file

    kubectl create configmap vault-config --from-file=configs/vault.hcl
    kubectl get configmap vault-config -o json | jq .


Create secret for Vault HTTPS certificate and private key

    kubectl create secret generic vault-cert --from-file=vault.pem --from-file=vault-key.pem
    kubectl get secret vault-cert -o json | jq .


Create persistent volume

    kubectl apply -f manifests/vault-pvc.yaml

Create deployment

    kubectl apply -f manifests/vault.yaml
    kubectl get pods


## Configure Vault

Launch new shell in vault container

    # find vault pod name
    kubectl get pods
    kubectl exec -it vault-NNNNNNNNN ash


Initialize Vault in order to generate key shares

    http -v --verify=/run/secrets/kubernetes.io/serviceaccount/ca.crt \
    PUT https://localhost:8200/v1/sys/init \
    secret_shares:=1 secret_threshold:=1

    # init end-point result will contain field key and root_token.
    # set them to environment variables for using in following commands

    export UNSEAL_KEY=8c54dbe2c5489df89a2f61577223c93361f884038a87f47ae24d0b804ae8bf86
    export ROOT_TOKEN=60c8d58c-4621-3f2e-c649-9f2469300eeb

Unseal Vault with unseal key generated by previous step

    http -v --verify=/run/secrets/kubernetes.io/serviceaccount/ca.crt \
    PUT https://localhost:8200/v1/sys/unseal \
    key=$UNSEAL_KEY


Get the status

    http -v --verify=/run/secrets/kubernetes.io/serviceaccount/ca.crt \
    GET https://localhost:8200/v1/sys/health


Enable Kubernetes auth backend:

    http -v --verify=/run/secrets/kubernetes.io/serviceaccount/ca.crt \
    POST https://localhost:8200/v1/sys/auth/kubernetes \
    "X-Vault-Token: $ROOT_TOKEN" \
    type=kubernetes


Configure Kubernetes auth backend

    http -v --verify=/run/secrets/kubernetes.io/serviceaccount/ca.crt \
    POST https://localhost:8200/v1/auth/kubernetes/config \
    "X-Vault-Token: $ROOT_TOKEN" \
    kubernetes_host=https://kubernetes kubernetes_ca_cert=@/run/secrets/kubernetes.io/serviceaccount/ca.crt token_reviewer_jwt=@/var/run/secrets/kubernetes.io/serviceaccount/token


Create access policy

    http -v --verify=/run/secrets/kubernetes.io/serviceaccount/ca.crt \
    POST https://localhost:8200/v1/sys/policy/foo-reader \
    "X-Vault-Token: $ROOT_TOKEN" \
    policy="path \"secret/foo\" { capabilities = [\"read\"] }"


Create role and associate it to a policy

    http -v --verify=/run/secrets/kubernetes.io/serviceaccount/ca.crt \
    POST https://localhost:8200/v1/auth/kubernetes/role/demo-role \
    "X-Vault-Token: $ROOT_TOKEN" \
    bound_service_account_names=vault-client bound_service_account_namespaces=default policies=foo-reader

Create two secrets `secret/foo` and `secret/bar`

    http -v --verify=/run/secrets/kubernetes.io/serviceaccount/ca.crt \
    POST https://localhost:8200/v1/secret/foo \
    "X-Vault-Token: $ROOT_TOKEN" \
    mysecret=foo

    http -v --verify=/run/secrets/kubernetes.io/serviceaccount/ca.crt \
    POST https://localhost:8200/v1/secret/bar \
    "X-Vault-Token: $ROOT_TOKEN" \
    mysecret=bar


## Access Vault with Kubernetes Service Account

Create client deployment and connect to it

    kubectl apply -f manifests/client.yaml

    # find out the client pod id
    kubectl get pods
    kubectl exec -it client-NNNNNNNN ash


Login with Service Account

    http -v --verify=/run/secrets/kubernetes.io/serviceaccount/ca.crt \
    POST https://vault:8200/v1/auth/kubernetes/login \
    role=demo-role jwt=@/var/run/secrets/kubernetes.io/serviceaccount/token

    # auth end-point result will contain field client_token.
    # set it to environment variable
    export CLIENT_TOKEN=24ad5ad8-db06-9e3b-dd46-fdee72414d54


Read secret `secret/foo`

    http -v --verify=/run/secrets/kubernetes.io/serviceaccount/ca.crt \
    GET https://vault:8200/v1/secret/foo \
    "X-Vault-Token: $CLIENT_TOKEN"


The policy will NOT allow reading `secret/bar`

    http -v --verify=/run/secrets/kubernetes.io/serviceaccount/ca.crt \
    GET https://vault:8200/v1/secret/bar \
    "X-Vault-Token: $CLIENT_TOKEN"
