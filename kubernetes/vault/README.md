

# Using Vault PKI backend for bootstrapping container security


## Deploy Vault

In this tutorial we use Vault development server from docker hub

    kubectl apply -f manifests/vault-dev-deployment.yaml
    kubectl port-forward <pod_name> 8200


Development server uses HTTP instead of HTTPS so we need to override
the default URI

    export VAULT_ADDR="http://localhost:8200"


Authenticate towards the server by using the root token:

    vault auth my-root-token


Check that connectivity works

    vault status
    vault mounts


## Prepare CA

Configure Vault PKI backend as root CA

    vault mount pki
    vault write pki/root/generate/internal common_name="my app root CA"


Create "role" which defines the behavior of the CA when issuing
certificates by using the role.

    vault write pki/roles/pods allowed_domains="svc.cluster.local" allow_subdomains=true max_ttl=72h


or alternatively if not using domain names

    vault write pki/roles/pods allow_any_name=true max_ttl=72h


List the effective parameters for the role:

    vault read pki/roles/pods


## Prepare auth token for accessing Vault

First create role and set policy for that role

    vault policy-write pods policies/pods.hcl
    vault write auth/token/roles/pods allowed_policies=pods


Then create authentication token

    vault token-create -role=pods


By default Vault uses token stored in ~/.vault-token which is the root
token that was typed in "Deploy Vault" chapter above.  To use the
newly created token, while still maintaining root token as default,
you can use

    VAULT_TOKEN=<token> <vault command>


or to overwrite the current default token, run:

    vault auth <token>


## Issue certificates


Issue client/server certificate

    vault write pki/issue/pods common_name="my-test-cert.default.svc.cluster.local"


Note that also private key was generated by Vault, but it will not be
stored by Vault.

There is alternative approach where private key is generate locally and only signing request is sent to Vault:

    openssl genrsa -out node-key.pem 2048
    openssl req -new -sha256 -key node-key.pem -out node.csr


To show the request details:

    openssl req -in node.csr -text -noout


Use the "sign" API endpoint to issue certificate:

    vault write pki/sign/pods csr=@node.csr


To list issued certificates and print their details execute following:

    vault list pki/certs
    vault read -field=certificate pki/cert/<serial> | openssl x509 -text -noout


You can see that the public key part is the same as listed by "openssl rsa":

    openssl rsa -in node-key.pem -text -noout




## Automating certificate enrollment in Kubernetes


### Listening Kubernetes events for newly created pods

Here is one potential approach for automatically distributing certificates to
pods.  It is just an proof-of-concept and should NOT be considered as something
that can be taken into use as it is!

Deploy client and server pods

    kubectl apply -f manifests/automatic-certificate-enrollment-1.yaml



### Using init container to fetch certificates

Create secret with Vault token

    kubectl create secret generic vault-token --from-literal=VAULT_TOKEN=<token>


Deploy client and server pods

    kubectl apply -f manifests/automatic-certificate-enrollment-2.yaml


### Test procedure


Connect to client and server and check that certificates and key are available

    kubectl exec -it <pod> ash

    ls -l /var/run/secrets/certs
    cat /var/run/secrets/certs/*


Install openssl

    apk add -U openssl


Run on server and client

    openssl s_server -key /var/run/secrets/certs/key.pem -cert /var/run/secrets/certs/cert.pem

    openssl s_client -connect server.default.svc.cluster.local:4433 -CAfile /var/run/secrets/certs/ca-cert.pem -verify_hostname server.default.svc.cluster.local
    openssl s_client -connect server:4433 | openssl x509 -text -noout



To see logs from certificate manager run

    kubectl logs -f <pod>


To see logs from certificate fetcher init container

    kubectl logs <pod> -c certificate-fetcher


## TODO

- docker container for certificate manager and manifest
- how to initialize certificate manager initial token (hardcode to manifest, use secrets?)
- how to bootstrap vault https certificates (manually, then replace with vault generated certs?)
- automatic rotation of certificates with short periods, restart applications using them
- san hostname field vs namespaces and domains vs vault pki allowed_domains 
- approle use for giving pods access to vault
- security relies on kubernetes installation: authentication enabled, authorization needs to be configured as well as HTTPS for API server communication, default service accounts needs to be disabled / limited by policy, only trusted images allowed
- example application
- possible race-condition problem with kubernetes secret and update period (defaultTtl = minute https://github.com/kubernetes/kubernetes/blob/master/pkg/kubelet/secret/secret_manager.go)
- different approaches like https://github.com/Boostport/kubernetes-vault with init container and shared volume vs k8s secrets as communication mechanism
- example on using vault as intermediate ca


## Building demo containers

Following instructions assume that minikube is used as test environment

    eval $(minikube docker-env)
    docker build --tag certificate-manager:latest certificate-manager
    docker build --tag certificate-fetcher:latest certificate-fetcher




## Documentation

Vault Documentation

* General https://www.vaultproject.io/docs/index.html
* API https://www.vaultproject.io/api/index.html

Python APIs

* Kubernetes Python API https://github.com/kubernetes-incubator/client-python/blob/master/kubernetes/README.md
* Vault Python API https://github.com/ianunruh/hvac
